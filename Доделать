import sys
import ccxt
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5.QtWidgets import QApplication, QMainWindow, QTextEdit, QComboBox, QPushButton
from PyQt5.QtCore import Qt
from datetime import datetime
from PyQt5.QtCore import QTimer

# Шаг 1: Получаем данные с Binance API
def fetch_binance_data(symbol='BTC/USDT', timeframe='1d', limit=100):
    exchange = ccxt.binance()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
    
    # Преобразуем данные в DataFrame
    data = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
    data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
    
    return data

# Шаг 2: Расчет индикаторов

# 2.1: Расчет 50-дневной скользящей средней
def calculate_sma(data, window=50):
    data['SMA50'] = data['close'].rolling(window=window).mean()

# 2.2: Расчет RSI
def calculate_rsi(data, window=14):
    delta = data['close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    data['RSI'] = rsi

# Шаг 3: Генерация торговых сигналов
def generate_signal(data):
    signal = ""
    
    # Проверка сигналов по RSI
    if data['RSI'].iloc[-1] < 30:
        signal += "Покупка: Актив перепродан, RSI ниже 30.\n"
    elif data['RSI'].iloc[-1] > 70:
        signal += "Продажа: Актив перекуплен, RSI выше 70.\n"
    else:
        signal += "RSI: Рынок в нейтральной зоне.\n"
    
    # Проверка сигналов по скользящим средним (SMA)
    if data['close'].iloc[-1] > data['SMA50'].iloc[-1]:
        signal += "Дополнительный сигнал: Цена выше SMA50 — потенциальный рост.\n"
    elif data['close'].iloc[-1] < data['SMA50'].iloc[-1]:
        signal += "Дополнительный сигнал: Цена ниже SMA50 — потенциальное падение.\n"
    
    # Сигнал в случае, если цена пересекает SMA
    if data['close'].iloc[-2] < data['SMA50'].iloc[-2] and data['close'].iloc[-1] > data['SMA50'].iloc[-1]:
        signal += "Пересечение: Цена пересекла 50-дневную SMA снизу вверх — возможный сигнал на покупку.\n"
    elif data['close'].iloc[-2] > data['SMA50'].iloc[-2] and data['close'].iloc[-1] < data['SMA50'].iloc[-1]:
        signal += "Пересечение: Цена пересекла 50-дневную SMA сверху вниз — возможный сигнал на продажу.\n"
    
    # Если нет явных сигналов, то рынок в нейтральной зоне
    if signal == "":
        signal = "Нет сигнала: Рынок в нейтральной зоне."
    
    return signal

# Шаг 4: Визуализация графика с Matplotlib в PyQt5 (отдельное окно для графика)
class PlotWindow(QMainWindow):
    def __init__(self, data, symbol='BTC/USDT'):
        super().__init__()

        self.setWindowTitle(f"График {symbol}")
        self.setGeometry(100, 100, 800, 600)

        # Создаем фигуру для графика с Matplotlib
        fig, ax = plt.subplots(figsize=(8, 5))
        
        # Строим график цен (close price)
        ax.plot(data['timestamp'], data['close'], label='Цена закрытия', color='blue', lw=2)

        # Добавляем скользящую среднюю
        ax.plot(data['timestamp'], data['SMA50'], label='50-дневная SMA', color='red', lw=2)

        # Заголовок и метки
        ax.set_title(f"График цен {symbol}")
        ax.set_xlabel("Дата")
        ax.set_ylabel("Цена (USDT)")
        ax.legend()

        # Вставляем график в PyQt5 с помощью FigureCanvas
        self.canvas = FigureCanvas(fig)
        self.setCentralWidget(self.canvas)

# Шаг 5: Визуализация текстового анализа в отдельном окне
class TextWindow(QMainWindow):
    def __init__(self, data, symbol='BTC/USDT'):
        super().__init__()

        self.setWindowTitle("Технический анализ")
        self.setGeometry(950, 100, 600, 400)

        # Добавляем виджет для текста
        self.text_edit = QTextEdit(self)
        self.text_edit.setReadOnly(True)
        self.setCentralWidget(self.text_edit)

        self.symbol = symbol
        self.update_text(data)

        # Создаем таймер для обновления текста каждую минуту
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_data)
        self.timer.start(60000)  # обновление каждую минуту

    def update_text(self, data):
        signal = generate_signal(data)

        # Используем текущее время для отображения времени последнего обновления
        current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        text = f"Рынок: {self.symbol}\n"
        text += f"Время последнего обновления: {current_time}\n"
        text += f"Цена закрытия последней свечи: {data['close'].iloc[-1]}\n\n"
        text += "Анализ:\n"
        text += signal

        # Вставляем текст в текстовое окно
        self.text_edit.setText(text)

    def refresh_data(self):
        """Обновляем данные и текстовое окно"""
        data = fetch_binance_data(self.symbol)
        calculate_sma(data)
        calculate_rsi(data)
        self.update_text(data)

# Шаг 6: Добавляем выбор валютной пары через ComboBox
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Выбор валютной пары")
        self.setGeometry(100, 100, 400, 200)

        # Получаем список всех валютных пар с Binance
        self.exchange = ccxt.binance()
        markets = self.exchange.fetch_markets()

        # Фильтруем валютные пары, оставляем только те, у которых первая валюта - BTC
        self.symbols = [market['symbol'] for market in markets if market['active'] and market['symbol'].startswith('BTC/')]

        # Добавляем ComboBox для выбора криптовалюты
        self.combo_crypto = QComboBox(self)
        self.combo_crypto.addItems(['Bitcoin', 'Ethereum', 'Tether USDt', 'Solana', 'BNB', 'XRP', 'Dogecoin', 'USDC', 'Cardano', 'Avalanche'])
        self.combo_crypto.setGeometry(50, 50, 300, 30)

        # Добавляем ComboBox для выбора валюты (USD, EUR и т.п.)
        self.combo_currency = QComboBox(self)
        self.combo_currency.addItems(['USDT', 'USD', 'EUR'])
        self.combo_currency.setGeometry(50, 100, 300, 30)

        self.combo_crypto.currentIndexChanged.connect(self.on_symbol_change)
        self.combo_currency.currentIndexChanged.connect(self.on_currency_change)

        # Кнопка для открытия анализа
        self.button = QPushButton("Запустить анализ", self)
        self.button.setGeometry(50, 150, 300, 30)
        self.button.clicked.connect(self.run_analysis)

        self.selected_crypto = 'BTC'
        self.selected_currency = 'USDT'

    def on_symbol_change(self):
        """Обработчик изменения криптовалюты"""
        self.selected_crypto = self.combo_crypto.currentText()
        print(f"Выбрана криптовалюта: {self.selected_crypto}")

    def on_currency_change(self):
        """Обработчик изменения валюты"""
        self.selected_currency = self.combo_currency.currentText()
        print(f"Выбрана валюта: {self.selected_currency}")

    def run_analysis(self):
        """Запускаем анализ для выбранной валютной пары"""
        symbol = f"{self.selected_crypto}/{self.selected_currency}"
        data = fetch_binance_data(symbol)
        calculate_sma(data)
        calculate_rsi(data)

        # Создаем окна с графиком и анализом
        self.plot_window = PlotWindow(data, symbol)
        self.text_window = TextWindow(data, symbol)

        self.plot_window.show()
        self.text_window.show()

# Шаг 7: Основная функция
def analyze_market():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

# Запуск приложения
analyze_market()
